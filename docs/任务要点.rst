任务要点
===================================


1. 任务消息不会从消息队列移除, 除非有worker已经对其进行过确认acknowledged

2. 一个worker可以提前保留多个消息, 即使其异常退出了, 这些消息会被重新传递给其他worker

3. 理想的任务函数是幂等的: 意味着一个函数在参数不变的情况下即使被调用多次, 也不会造成意想不到的影响

4. 由于没有办法检测任务是否是幂等的, 因此默认的行为是在执行完毕之前提前确认消息, 那么一个已经开始的任务不会被重复执行

5. 如果我们的任务是幂等的, 那么我们需要设置task_acks_late选项使worker在执行完毕任务以后才确认消息

6. 如果正在执行任务的子进程被结束了(要么是任务主动调用sys.exit(),要么被信号), 那么worker还是会确认消息, 即使task_acks_late被开启了 ::

    A. 首先我们不想重新运行这种可能有段错误导致内核发送SIGSEGV或其他类似信号的任务
    B. 我们假设是系统管理员故意kill掉这个任务的, 那么他肯定不希望重启此任务
    C. 一个任务可能占用太多内存而触发内核的OOM Killer机制, 相同的情况可能会再次发生
    D. 一个被重新传递的任务经常失败可能导致高频率的消息循环, 会降低系统性能
    
    如果你真的希望这种情况下还是重新传递此任务, 那么可以使能task_reject_on_worker_lost选项
    
7. 如果任务无限期地阻塞下去可能会导致worker无法做其他工作, 这意味着进行I/O操作时最好设置超时时间

8. Time limits可以很方便地确保所有任务能及时返回, 但是超时事件会强制worker进程退出, 因此只用来检测哪些地方的I/O没有设置超时时间

9. 默认的prefork池调度器对于耗时较长的任务很不友好, 因此需要在运行worker时添加-Ofair命令行参数

10. 任务的自动命名会根据你的绝对导入、相对倒入而有所差异, 最好的实践是保持一致的导入原则或者给每个任务显示命名